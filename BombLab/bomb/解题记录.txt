第一题：字符串是固定的，存储在某个内存地址上，直接找到内存地址并依次读取即可，当然可以先找出字符串长度然后再翻译内存地址中的字符串，也可以直接根据字符串结束的\0直接判断。
第二题：字符串是固定的，从用户输入的字符串中读取6个数字，然后存储在寄存器和栈中，首先第一个数必须是1，然后进入一个循环不断判断当前值是否为上一个值得2倍，若不是则爆炸。
第三题：字符串不是固定的，从用户输入的字符串中读取两个整数，根据第一个整数的值通过switch来判断第二个整数的值是否为某个固定值，否则就爆炸，注意第一个数要小于8。
第四题：这个题很奇葩，从用户输入的字符串中读入两个整数，首先第二个数一定是0，然后中间调用了一个函数func4，最后要求这个函数的返回值也要是0，否则就会爆炸，注意这个函数是个递归函数，整理过之后发现只要第一个参数的值等于（0+14）/2向下舍入时的结果，那么可以直接返回同时这时的返回值恰巧被清零了，那其他的分支是干嘛的呢？
第五题：这个题还算正常答案应该不唯一，首先根据用户输入的字符串，一共6个，提取它们的低4位作为偏移量到一个数组中取得5个新字符，然后将这几个新字符与预定的某个地址处的6个字符进行比较，比较成功即破解。
第六题：汇编代码相对较长，但多数都是忽悠人的，首先从用户输入的字符串中读入六个整数，然后进入一个循环，保证不会有大于6的数并且它们都是互不相同的，这一段代码较长，要会寻找与后续代码的分割点，从而将这段代码独立出来分析，就可以发现可以等价成一个for循环，紧接着又是一个循环，同样将它与后续代码分割开来，可以发现依旧是一个for循环，把读入到栈上的六个整数用7减，即x变为7-x。接下来的也是同样的策略，但是这个比较让人头疼，要抽出来一个for循环有点挑战，主要是其内部有一个条件判断，根据当前所指栈上的值赋给rdx不同的地址，等价表达式为rdx=0x6032d0+8*(x-1)，主要是处理了当x<1时的边界情况使得代码逻辑变得复杂。接下来一段感觉完全是忽悠人的，所做的处理不会影响接下来的判断。最后一段则是挨个判断上面计算出来的六个地址所指的实际数据的大小关系，地址范围是固定的，地址中存的整数也是固定的，只要逆向推导出大小关系，还原过去即可。
隐藏关卡：在最后一个关卡的汇编代码下面会发现有一个隐藏关卡，在vim中搜索secret即可发现其调用是在phase_defused函数中。据猜测phase_defused函数中有一个变量记录调用次数，必须在破解了前六个之后才会进入。进入之前会检查某个地址处的字符串是否与指定字符串相同，我们只要将这个字符串放在第四题输入的两个整数后面就会被%s读入。成功进入隐藏关卡之后，从用户输入的字符串中读取一个整数，该整数不能超过1001，然后进入一个递归程序，该递归程序最终必须返回2，反向推导递归路径只有edx>esi,edx<esi,edx>esi,edx=esi符合递归要求，然后分析内存中的二叉树状的表格，得出整数必须是20。